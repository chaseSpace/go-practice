## JS 的类型

|    类型     |     值      |                  描述                  |
|:---------:|:----------:|:------------------------------------:|
| Undefined | undefined  |                 未定义                  |
|   Null    |    null    |                 空对象                  |
|  Boolean  | true/false |                 布尔值                  |
|  Number   | 任何数值，含浮点数  |                  数值                  |
|  String   |    字符串     | 字符串，最大长度是 2^53 - 1；<br/>JS中是UTF16 编码 |
|  Symbol   |    符号值     |                 符号值                  |
|  Object   |    对象值     |                  对象                  |
| Function  |    函数值     |                  函数                  |

### String

JS 中的字符串是UTF16 编码，最大长度是 2^53 - 1。字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF16 编码。
字符串的最大长度，实际上是受字符串的编码长度影响的。

JS的字符串是不可变的，不能修改，所以属于值类型。此外JS把每个 UTF16 单元当作一个字符来处理（所以处理非 BMP（超出 U+0000 -
U+FFFF 范围）的字符时，你应该格外小心）。这个设计继承自 Java，最新标准中是这样解释的，这样设计是为了“性能和尽可能实现起来简单”。因为现实中很少用到
BMP 之外的字符。

### Number

Number 类型表示我们通常意义上的“数字”。这个数字大致对应数学中的有理数，当然，在计算机中，我们有一定的精度限制。

JavaScript 中的 Number 类型有 18437736874454810627(即 2^64-2^53+3) 个值。JavaScript 中的 Number 类型基本符合 IEEE
754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：
NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；

引入两个特殊值：`Infinity` 和 `-Infinity`，用来表示正无穷大和负无穷大。

特殊情况：存在 `+0` 和 `-0`，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分。除以 `-0`，会得到负无穷大。
区分 `+0` 和 `-0` 的方式，正是检测 `1/x` 是 `Infinity` 还是 `-Infinity`。

> [!NOTE]
> - 根据双精度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number
    无法精确表示此范围外的整数。
> - 同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较，一段著名的代码，这也回答了JS中的经典问题 【为何
    0.1+0.2 不等于 0.3？】：

### Symbol

Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。

### Object

Object 是 JavaScript 中最复杂的类型，也是 JavaScript 的**核心机制**之一。Object 表示对象的意思，它是一切有形和无形物体的总称。

- 对象的定义是“属性的集合”。属性分为数据属性和访问器属性；
- key 可以是字符串或者 Symbol 类型，而值可以是任何类型；
- JS中的其他类型如Number、String、Boolean等都是基本类型，它们不像对象那样拥有属性和方法；

#### 具有两用性的构造函数

JS中，Number、String 和 Boolean，三个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接调用时，它们表示强制类型转换。

Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

#### 模糊性

JavaScript 语言设计上试图模糊对象和基本类型之间的关系，我们日常代码可以把对象的方法在基本类型上使用，比如：

```js
console.log("abc".charAt(0)); //a
```

甚至我们在原型上添加方法，都可以应用于基本类型：

```js
String.prototype.hello = () => console.log("hello");
```

### 类型转换

JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算都会先进行类型转换。
大部分类型转换符合人类的直觉，但是如果我们不去理解类型转换的严格定义，很容易造成一些代码中的判断失误！

> [!NOTE]
> 其中最为臭名昭著的是 JS 中的“ == ”运算，因为试图实现跨类型的比较，它的规则复杂到几乎没人可以记住。

其它运算，如加减乘除大于小于，也都会涉及类型转换。幸好的是，实际上大部分类型转换规则是非常简单的。

#### == 和 ===

**==**：在比较两个值之前，会进行类型转换（也称为类型强制或类型提升），尝试将两个值转换为相同的类型，然后再进行比较。这意味着即使两个值的原始类型不同，
它们也可能被认为是相等的。例如，`"2" == 2` 会返回 `true`，因为字符串 "2" 被转换为数字 2。

> [!IMPORTANT]
> == 在JS中属于设计失误，实践中经常被禁止使用。

**===**：不会进行类型转换。如果两个值的类型不同，比较将立即返回 false。只有当两个值的类型和值都相同时，`===` 才会返回
true。例如，`"2" === 2` 会返回 `false`，因为一个是字符串，另一个是数字。

#### 测试用例

[func：test_type_conversion_string2num](testcode%2Fjs.1.%B9%D8%D3%DA%C0%E0%D0%CD.js)

### 装箱（Boxing）

在 JavaScript 中，装箱（Boxing）是指将基本类型（原始类型）转换为对象类型的过程。
JavaScript 有六种基本类型：Number（数字）、String（字符串）、Boolean（布尔值）、Symbol（符号）、null 和 undefined。除了 null 和
undefined，其他四种基本类型在对象中都有对应的构造函数。

#### 装箱的意义和注意点

**意义: 灵活性**

通过装箱，基本类型可以临时获得对象的特性，如**添加属性或调用方法**。

**注意点: 性能考虑**

装箱可能会影响性能，因为创建对象需要额外的内存和处理。在性能敏感的应用中，应避免不必要的装箱。

#### 装箱的特征

- **自动装箱**：在需要对象的上下文中使用基本类型时，JavaScript 引擎会自动将基本类型转换为对应的对象类型。例如，当你尝试为一个字符串添加属性时，字符串会自动装箱为一个
  String 对象。
- **构造函数**：Number、String、Boolean 和 Symbol 都有对应的构造函数。使用 new 关键字调用这些构造函数可以创建相应类型的对象。例如，new
  Number(42) 创建一个 Number 对象，其值为 42。
- **Symbol 装箱**：Symbol 类型比较特殊，因为 Symbol 构造函数不能使用 new 关键字来创建 Symbol 对象，否则会抛出错误。但是，可以通过装箱机制来创建
  Symbol 对象。这可以通过将 this 关键字强制返回到一个 Symbol 值上实现，通常是通过函数的 call 或 apply 方法。
